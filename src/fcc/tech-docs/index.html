<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>React</title>
    <meta name="viewport" content="width=device-width">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans">
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Code+Pro">
    <link rel="stylesheet"
          href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/styles/atom-one-dark.min.css"></head>
<body>
    <nav id="navbar">
        <div id="navbar-wrapper">
            <header>React Documentation</header>
            <ul>
                <li><a class="nav-link" href="#introduction">Introduction</a></li>
                <li><a class="nav-link" href="#hello_world">Hello World</a></li>
                <li><a class="nav-link" href="#hooks">Hooks</a></li>
                <li><a class="nav-link" href="#class_components">Class Components</a></li>
                <li><a class="nav-link" href="#references">References</a></li>
            </ul>
        </div>
    </nav>
    <main id="main-doc">
        <section id="introduction" class="main-section">
            <header>Introduction</header>
            <p>React makes it painless to create interactive UIs. Design simple views for each state in your application, and React will efficiently update and render just the right components when your data changes.</p>
            <p>React will also allow you to build encapsulated components that manage their own state, then compose them to make complex UIs. Since component logic is written in JavaScript instead of templates, you can easily pass rich data through your app and keep state out of the DOM.</p>
        </section>
        <section id="hello_world" class="main-section">
            <header>Hello World</header>
            <p>
<pre><code class="lang-js">function HelloWorld() {
    return (
        &lt;div&gt;Hello World!&lt;/div&gt;
    );
}

ReactDOM.render(
    &lt;HelloWorld /&gt;,
    document.getElementById('hello-world-example')
);</code></pre>
            </p>
        </section>
        <section id="hooks" class="main-section">
            <header>Hooks</header>
            <p>Hooks solve a wide variety of seemingly unconnected problems in React that we’ve encountered over five years of writing and maintaining tens of thousands of components. Whether you’re learning React, use it daily, or even prefer a different library with a similar component model, you might recognize some of these problems.</p>
            <p>Here are are few of the basic hooks:</p>
            <ul>
                <li>useState</li>
                <li>useEffect</li>
                <li>useContext</li>
            </ul>
            <h3>useState</h3>
            <p>
                <pre><code class="lang-js">const [state, setState] = useState(initialState);</code></pre>
            </p>
            <p>
                As you can see in the code above, useState takes an initialState value.
                It returns to you an array of the first index being your current state value and the second index being the function to be able to update your current state.
            </p>
            <h3>useEffect</h3>
            <p>
<pre><code class="lang-js">useEffect(
    () => {
        const subscription = props.source.subscribe();
        return () => {
            subscription.unsubscribe();
        };
    },
    [props.source]
);</code></pre>
            </p>
            <p>
                As you can see in the code above, useEffect takes a function and an optional array of values to react to. The function will run after the component gets rendered on the UI. If a function is returned in that handler function, then React will run that returned function when the component gets removed from the UI. The value that you pass as the second argument will tell useEffect if it should run the handler after a render.
                <ul>
                    <li>No value
                        <ul>
                            <li>The handler will run after ever component render.</li>
                        </ul>
                    </li>
                    <li>An empty array
                        <ul>
                            <li>The handler will behave like the class component lifecycle methods componentDidMount and componentWillUnmount. Meaning they will only run the useEffect handler when the component gets created, and run the return value of the useEffect handler when the component gets destroyed.</li>
                        </ul>
                    </li>
                    <li>An array of values
                        <ul>
                            <li>This behaves almost the same as if you were to give it an empty array, but will also run your handler anytime that the values that you pass to the array change.</li>
                        </ul>
                    </li>
                </ul>
            </p>
            <h3>useContext</h3>
            <pre><code class="lang-js">const value = useContext(MyContext);</code></pre>
            <p>Accepts a context object (the value returned from React.createContext) and returns the current context value for that context. The current context value is determined by the value prop of the nearest &lt;MyContext.Provider&gt; above the calling component in the tree.</p>
            <p>When the nearest &lt;MyContext.Provider&gt; above the component updates, this Hook will trigger a rerender with the latest context value passed to that MyContext provider. Even if an ancestor uses React.memo or shouldComponentUpdate, a rerender will still happen starting at the component itself using useContext.</p>
            <p>Don’t forget that the argument to useContext must be the context object itself:</p>
            <ul>
                <li>Correct: useContext(MyContext)</li>
                <li>Incorrect: useContext(MyContext.Consumer)</li>
                <li>Incorrect: useContext(MyContext.Provider)</li>
            </ul>
            <p>A component calling useContext will always re-render when the context value changes. If re-rendering the component is expensive, you can optimize it by using memoization.</p>
        </section>
        <section id="class_components" class="main-section">
            <header>Class Components</header>
            <p>Note: Hooks are the preferred way for React development, so use React class components only when needed.</p>
            <p>React lets you define components as classes or functions. Components defined as classes currently provide more features which are described in detail on this page. To define a React component class, you need to extend React.Component:</p>
<pre><code class="lang-js">class Welcome extends React.Component {
    render() {
        return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
    }
}</code></pre>
            <h3>The Component Lifecycle Methods</h3>
            <ul>
                <li>componentDidCatch()</li>
                <li>componentDidMount()</li>
                <li>componentDidUpdate()</li>
                <li>componentWillUnmount()</li>
                <li>constructor()</li>
                <li>getSnapshotBeforeUpdate()</li>
                <li>render()</li>
                <li>static getDerivedStateFromProps()</li>
                <li>static getDerivedStateFromError()</li>
                <li>shouldComponentUpdate()</li>
            </ul>
        </section>
        <section id="references" class="main-section">
            <header>References</header>
            <p>
                <ul>
                    <li><a target="_blank" href="https://reactjs.org/">React</a></li>
                </ul>
            </p>
        </section>
    </main>
    <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.2/highlight.min.js"></script>
    <script src="https://cdn.freecodecamp.org/testable-projects-fcc/v1/bundle.js"></script>
</body>
</html>